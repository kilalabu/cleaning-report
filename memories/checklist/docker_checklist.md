# Docker 理解度チェックリスト (Deep Dive)

Dockerの基本的な使い方を超えて、**「コンテナ技術の本質」** と **「仕組み」** を深く理解するための問題集（全15問）です。
Android開発の知識と比較しながら、サーバーサイドエンジニアとしての基礎体力をつけましょう。

---

## 📚 セクション1: コンテナの仕組みと構造

### Q1. Dockerコンテナと「仮想マシン (VM)」の構造的な違いに関する説明で、正しいものは？

- A) VMはホストOSの上に「ハイパーバイザ」を介してゲストOSを動作させるが、DockerコンテナはホストOSの「カーネル」を共有し、プロセスとして動作する。
- B) DockerコンテナはVMの一種であり、軽量化されたゲストOS（Linux Kernel）を個別に持っているため、起動が少し遅い。
- C) VMはハードウェアをエミュレーションするが、DockerはCPUやメモリを直接占有するため、ホストOSからはプロセスとして見えない。
- D) Dockerコンテナはアプリケーションコードしか持たず、OSの機能（ファイルシステムやネットワーク）は持っていない。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
- **VM**: 完全に独立したハードウェアとOSを再現します。隔離性は高いですが、OSが複数動くため重いです。
- **Docker**: ホストOSのカーネルを共有しつつ、Linuxの機能（Namespace, Cgroups）を使って「隔離された空間」を作ります。ホストから見ればただの「プロセス」ですが、中からは独立したOSに見えます。だから軽量で高速なのです。

**❌ 不正解の解説:**
- **B**: DockerはゲストOSを持ちません。ここがVMとの最大の違いであり、起動速度の差（分単位 vs 秒単位）の理由です。
- **C**: DockerプロセスはホストOSから普通に見えます（`ps aux` コマンドで見えます）。あくまで「見えないフリ（隔離）」をしているだけです。

</details>

---

### Q2. Dockerにおける「デーモン (Docker Daemon / dockerd)」の正しい説明は？

- A) コンテナの内部で実行されるメインプロセス（PID 1）のことであり、アプリがクラッシュするとデーモンも停止する。
- B) コンテナイメージをビルドする時だけ起動する一時的なコンパイラのようなツール。
- C) ホストマシン上でバックグラウンド実行され、クライアントからの命令を受けてイメージ管理やコンテナ実行を行う常駐プロセス。
- D) Docker Hubと通信するためだけの専用プロキシサーバー。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
Dockerは**クライアント・サーバー型**のアーキテクチャです。
私たちがターミナルで打つ `docker` コマンドはただの「クライアント（依頼人）」です。
実際の仕事（コンテナ起動、イメージDLなど）は、バックグラウンドで静かに常駐している **Dockerデーモン (`dockerd`)** が行います。

**❌ 不正解の解説:**
- **A**: それは「エントリーポイント」または「メインプロセス」です。デーモンはコンテナの**外**（ホスト上）にいて、全てのコンテナを管理しています。
- **B**: デーモンは常に起動している必要があります（サーバーのようなもの）。

</details>

---

### Q3. Dockerイメージの「レイヤー構造」について正しい説明は？

- A) イメージはビルド日時ごとにスナップショットが取られるため、古いレイヤーを削除するにはイメージ全体を作り直す必要がある。
- B) 上位のレイヤーでファイルを削除すると、下位のレイヤーからも物理的にファイルが削除され、イメージサイズが小さくなる。
- C) レイヤー構造はコンテナ実行時のメモリ使用量を減らすための仕組みであり、ディスク容量には影響しない。
- D) イメージは「読み取り専用の層（レイヤー）」の積み重ねでできており、変更された層以降だけを再ビルドすれば良いため、キャッシュが効きやすい。

<details>
<summary>答えを見る</summary>

**正解: D**

**解説:**
Dockerイメージは、`FROM Ubuntu` → `Install Java` → `Copy App` のように積み重なっています。

**❌ 不正解の解説（重要）:**
- **B**: これが最も頻出する間違いです！上位レイヤーでファイルを `rm` しても、それは「見えなくしている（ホワイトアウト）」だけで、下位レイヤーにはデータが物理的に残っています。イメージサイズは減りません。
- **A**: 部分的には再利用可能です（キャッシュ）。

</details>

---

### Q4. `docker run -p 8080:80` におけるポートフォワーディングの挙動として正しいのは？

- A) コンテナ内のアプリが、ホストマシンのポート80を使って外部へアクセスできるようにする（Outbound通信の許可）。
- B) コンテナ内部のポートを8080から80へ書き換える設定であり、ホスト側のポートは関係ない。
- C) ホストマシンのポート8080へのアクセスを、コンテナ内のポート80へ転送する。これを設定しないと外部からコンテナにはアクセスできない。
- D) 複数のコンテナ間で通信する場合にのみ必要な設定であり、ホストからのアクセスには不要。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
コンテナはデフォルトで外部からの通信を遮断しています（Inbound拒否）。
Dockerホスト（自分のPC）の特定のポートを「入り口」として開放し、それをコンテナのポートへ繋ぐパイプを作る必要があります。

**❌ 不正解の解説:**
- **A**: アウトバウンド（コンテナから外への通信）は、この設定なしでも自由にできます。`-p` はあくまでインバウンド（外から中への通信）のための設定です。
- **D**: 逆です。コンテナ間通信（Docker Network内）の場合は `-p` は不要です。ホスト（PCのブラウザなど）からアクセスする場合にのみ `-p` が必要です。

</details>

---

## 📚 セクション2: データの扱いと永続化

### Q5. コンテナを削除 (`docker rm`) した場合、コンテナ内で生成されたファイル（ログやDBデータ）はどうなる？

- A) `CoW (Copy on Write)` レイヤーにあるため、コンテナの停止・削除とともに完全に消滅する。
- B) イメージの一部としてコミットされるため、次回同じイメージから起動した際に復元される。
- C) 自動的に `/var/lib/docker/tmp` にバックアップされる。
- D) コンテナ削除コマンドに `--volumes` オプションを付けない限り、見えない状態で保持され続ける。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
コンテナ実行中のファイル変更は、イメージの上に乗った薄い「書き込みレイヤー」に行われます。
このレイヤーはコンテナというプロセスと一蓮托生です。削除すれば跡形もなく消えます。

**❌ 不正解の解説:**
- **B**: コンテナへの書き込みはイメージ（読み取り専用）には一切反映されません。イメージを変えるには `docker build` か `docker commit` が必要です。
- **D**: これは **Volume** を使っていた場合の挙動です。Volumeを使わず、コンテナ内部のファイルシステムに直接書いたデータは、オプションに関係なく消えます。

</details>

---

### Q6. `docker volume` (ボリューム) をマウントする主な理由は何か？

- A) コンテナの起動速度を上げるため（ディスクI/Oの高速化）。
- B) ホスト側のファイルシステムとコンテナ内の特定のディレクトリをリンクさせ、コンテナを削除してもデータが永続的に残るようにするため。
- C) 複数のコンテナ間で設定ファイルを共有するためだけに使われる。
- D) コンテナのメモリ使用量を節約するため。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
**Docker Volume** は、コンテナのライフサイクルから切り離された「永続的な保存領域」です。
AndroidアプリをアンインストールしてもSDカードの写真が残るように、コンテナを削除してもVolume内のデータは消えません。

**❌ 不正解の解説:**
- **A**: むしろVolume（特にホストのディレクトリをマウントする Bind Mount）は、Docker Desktop for Mac などではオーバーヘッドによりI/Oが遅くなることがあります。速度目的ではありません。

</details>

---

### Q7. アプリの設定（DBのパスワードなど）を設定ファイルに書かずに「環境変数」を使う主な理由は？

- A) 環境変数のほうがアプリケーションからの読み込み速度が速いから。
- B) 設定ファイル (`config.json` 等) はDockerイメージに含めることができないから。
- C) 環境変数はOS再起動時にクリアされるため、セキュリティが高いから。
- D) コードやDockerイメージを変更・再ビルドすることなく、実行時（デプロイ時）に外部から動的に設定値を注入できるから。

<details>
<summary>答えを見る</summary>

**正解: D**

**解説:**
本番環境と開発環境でDBの接続先やパスワードは異なります。
環境変数を使えば、「全く同じDockerイメージ」を、開発・検証・本番すべての環境で使い回すことができます（Build Once, Run Anywhere）。

**❌ 不正解の解説:**
- **B**: イメージに含めることは可能ですが、それだと「本番用イメージ」「開発用イメージ」など環境ごとにビルドが必要になり、Dockerのメリットが失われます。

</details>

---

## 📚 セクション3: Dockerfile と最適化

### Q8. Dockerfile で `COPY . .` する前に `COPY build.gradle.kts .` などを書いて依存解決 (`RUN gradle dependencies`) するテクニックの目的は？

```dockerfile
# 悪い例
COPY . .
RUN gradle build

# 良い例
COPY build.gradle.kts .
RUN gradle dependencies  # ← ここでライブラリをダウンロード
COPY . .
RUN gradle build
```

- A) ソースコード内にビルドスクリプトが含まれていない場合にエラーになるのを防ぐため。
- B) 並列ビルドを有効にしてGradleの処理速度を上げるため。
- C) ライブラリのダウンロード（依存解決）の結果をキャッシュさせ、ソースコード（`src/`）の変更時にはそのキャッシュを再利用してビルド時間を短縮するため。
- D) マルチステージビルドを行うための必須構文だから。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
Dockerは、`COPY` したファイルの中身が変わると、それ以降の行（`RUN`など）は「キャッシュ無効」と判断して再実行します。
**ソースコードは頻繁に変わりますが、`build.gradle.kts` はめったに変わりません。**
先に `build.gradle.kts` だけをコピーして依存解決しておけば、ソースだけ書き換えたときに重いライブラリDLをスキップできます。

</details>

---

### Q9. ベースイメージとして `alpine` 版（例: `openjdk:17-alpine`）を選ぶ際の注意点は？

- A) 標準的なCライブラリ (glibc) ではなく軽量な musl libc を使用しているため、一部のJavaライブラリやネイティブ拡張が動作しない、またはパフォーマンスが出ない場合がある。
- B) AlpineはWindowsベースなので、Linuxコンテナとしては動作しない。
- C) イメージサイズが Debain/Ubuntu 版よりも大きくなる傾向がある。
- D) Alpine版は開発用であり、商用ライセンスが必要になる。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
- **Alpine Linux**: 極限まで軽量化されたLinux（数MB）。
- **メリット**: イメージサイズ削減、セキュリティ向上。
- **リスク**: 一般的なLinux（Debian/CentOS）とは標準ライブラリの実装が異なります。アプリがその差異に依存していると、「開発環境（Debian）では動いたのに本番（Alpine）でクラッシュする」という厄介な問題が起きます。

**❌ 不正解の解説:**
- **C**: 逆です。Alpineは圧倒的に小さいです（数百MB vs 数MB）。

</details>

---

## 📚 セクション4: 周辺エコシステム

### Q10. 「コンテナレジストリ (Container Registry)」の説明として正しいのは？

- A) コンテナを実行するためのホストサーバーのこと。
- B) 複数のコンテナを動かす際のオーケストレーションツール。
- C) ビルドされたDockerイメージを保管し、バージョン管理・配布を行うサーバー（リポジトリ）。
- D) Dockerの設定ファイルを自動生成するツール。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
- **Docker Hub** や **Google Artifact Registry** などがレジストリです。
「ビルド済みのアプリ置き場」としての役割を果たします。

**❌ 不正解の解説:**
- **A**: それは「Docker Host」や「Cluster (K8s)」です。レジストリは動かす場所ではなく、置いておく場所です。
- **B**: それは「Kubernetes」や「Docker Swarm」です。

</details>

---

### Q11. イメージにつける `latest` タグ（例: `myapp:latest`）を本番運用で避けるべき理由は？

- A) `latest` タグが付いていると、Dockerが常に最新のコミットコードを自動的にプルしてしまうため、意図しないコードがデプロイされるから。
- B) `latest` タグは開発環境専用であり、Cloud Runなどの本番環境ではデプロイ時にエラーになるから。
- C) `latest` タグを使うとイメージサイズが自動的に大きくなるから。
- D) `latest` は「最後にプッシュされたもの」という動的なポインタに過ぎず、中身が変わってもタグ名が変わらないため、デプロイされたバージョンが特定できず、ロールバックも困難になるから。

<details>
<summary>答えを見る</summary>

**正解: D**

**解説:**
`latest` は単なる「デフォルトの文字列」です。
`v1.0.0` や `sha-c3f2a1` のような不変のタグを使えば、「昨日動いていた `v1.0.0` に戻す」ことが確実にできますが、`latest` だと中身が上書きされてしまっているため、過去の状態に戻せません。

**❌ 不正解の解説:**
- **A**: Dockerはタグ名が変わらなければ（かつ `PullPolicy: Always` でなければ）ローカルの古いキャッシュを使い続けます。逆に「最新にならない」というトラブルも起きます。

</details>

---

## 📚 セクション5: 応用知識

### Q12. `docker-compose.yml` (Docker Compose) の役割として最も適切なのは？

- A) 単一のホスト上で、Web・DB・キャッシュなど複数の関連するコンテナの構成（ネットワーク、ボリューム、環境変数）を定義し、一括管理する。
- B) 複数のDockerホスト（サーバー）を管理し、クーバネティスのようにクラ スタリングを行う。
- C) Dockerfileの代替構文であり、イメージのビルド手順を記述する。
- D) 本番環境へのデプロイ専用の設定ファイルであり、開発環境では使用しない。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
実際のシステムは「Webサーバー」だけで動くことは少なく、「DB」や「Redis」など複数のサービスが連携します。
これらを個別に `docker run` するのは大変で、ネットワーク接続や起動順序の管理も複雑です。
**Docker Compose** を使えば、`docker-compose up` 一発でシステム全体を起動でき、開発環境の構築が劇的に楽になります。

</details>

---

### Q13. コンテナ間で通信する際、接続先ホスト名として `localhost` を使うと失敗する理由は？

- A) コンテナ内の `localhost` (127.0.0.1) は「そのコンテナ自身」を指すため、別のコンテナ（DBなど）を指すことはできないから。
- B) Dockerコンテナは `localhost` という名前解決をサポートしていないから。
- C) セキュリティ上の理由で、Dockerはコンテナ間の直接通信をデフォルトでブロックしているから。
- D) `localhost` はホストマシン（Mac/Windows）を指す予約語だから。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
コンテナはそれぞれ独立したネットワークを持っています。
Webコンテナの中で `localhost:5432` に接続しようとすると、他のコンテナではなく**自分の中（Webコンテナ内）**の Postgres を探しますが、当然いません。

**❌ 不正解の解説:**
- **B**: サポートしています。自分自身への通信に使えます。
- **D**: 予約語ではありません。ホストマシンを指したい場合は、特別なDNS名 `host.docker.internal`（Docker Desktopの場合）などを使います。

</details>

---

### Q14. コンテナ技術における「イミュータブル（不変）インフラストラクチャ」のメリットは？

- A) 一度起動したサーバーは設定変更ができないため、ハッカーによる改ざんを完全に防げる。
- B) データの書き込みができないため、データベースのバックアップが不要になる。
- C) OSやライブラリのアップデート時に、既存サーバーへパッチを当てるのではなく「新しいイメージへの交換」を行うため、環境不整合（構成ドリフト）を防ぎ、いつでも同じ状態を再現できる。
- D) サーバーの管理コストがゼロになる。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
従来のサーバー管理は、SSHでログインして変更を加えていましたが（ミュータブル）、これだと変更履歴が追えず、環境差異が発生します。
Dockerでは、「新しい設定を含んだ新しいイメージ」を作り、古いコンテナを捨てて新しいコンテナを起動します。

**❌ 不正解の解説:**
- **A**: コンテナも実行中は書き換え可能です（ハッキングもされ得ます）。ただし「再起動すれば元のきれいなイメージに戻る」という特性はあります。

</details>

---

## 🏆 完了目安

このチェックリストで **10問以上** 正解できれば、Dockerの基本的な概念はマスターできています。
特に **「レイヤー構造とキャッシュ」「Volumeによる永続化」「コンテナ間通信」「環境変数の活用」** は、開発効率とトラブルシューティングに直結する重要知識です。
