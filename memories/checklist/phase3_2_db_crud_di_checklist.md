# Phase 3.2: DB接続 & CRUD + DI導入 理解度チェックリスト

Phase 3.2（データベース接続、CRUD実装、DI導入）に関する**本質的な概念と設計意図**を理解するための問題集です。
コードの細かい文法よりも、「なぜそのライブラリを使うのか？」「なぜその設計にするのか？」といったアーキテクチャの理解を問います。

---

## 📚 セクション1: インフラ・データベース接続 (HikariCP)

### Q1. サーバーサイド開発において「コネクションプール（HikariCPなど）」を利用する最大の目的は？

- A) データベースのパスワードを暗号化してセキュリティを高めるため
- B) データベースへの接続（ハンドシェイク）確立にかかる高いコスト（時間・負荷）を削減し、スループットを向上させるため
- C) 複数のデータベース（Postgres, MySQLなど）を同時に扱うため
- D) データベースの容量不足を防ぐために、自動的に不要なデータを削除するため

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
データベースへの接続確立（TCPハンドシェイク、認証など）は、SQL実行そのものよりも時間がかかる重い処理（約100ms〜）です。
サーバーは多数のリクエストを同時にさばく必要があるため、リクエストのたびに接続→切断を繰り返すとパフォーマンスが劇的に低下します。
**コネクションプール**は、あらかじめ確立した接続を「プール（溜め池）」に保持し、それを使い回すことでこのオーバーヘッドを解消します。

</details>

---

### Q2. Supabase（特に無料枠）を利用する場合、HikariCPの `maximumPoolSize`（最大接続数）の設定で注意すべき点は？

- A) ユーザー数が増えることを見越して、最初から `100` 以上に設定しておくのがベストプラクティスである。
- B) `0` に設定すると、自動的に最適な数が割り当てられる。
- C) データベース側の接続数制限（Connection Limit）を超えないように、少なめ（例: 3〜5）に設定する必要がある。
- D) この設定はパフォーマンスに関係しないため、デフォルトのままで良い。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
Supabaseの無料枠（Micro compute）などは、データベースが受け入れられる同時接続数に厳しい制限があります（数十程度）。
これを超えて接続しようとすると、アプリが `FATAL: remaining connection slots are reserved...` といったエラーでクラッシュします。
サーバー（Cloud Runなど）がオートスケールしてインスタンスが増えることも考慮し、1インスタンスあたりの接続数は少なめに設定するのが安全です。

</details>

---

### Q3. クラウド上のDB（Supabaseなど）に接続する際、`sslmode = "require"` を設定する理由は？

- A) データベースのパスワードを短くするため
- B) 通信経路を暗号化し、インターネット上での盗聴や改ざん（中間者攻撃）を防ぐため
- C) データベースの検索速度を向上させるため
- D) 接続プールを使わずに直接接続するため

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
ローカル開発（`localhost`）とは異なり、クラウドDBへの接続はインターネットを経由します。
`sslmode=require`（またはそれ以上）を設定しないと、SQLの内容やパスワードが平文で流れる可能性があり、セキュリティ上の重大なリスクとなります。

</details>

---

## 📚 セクション2: ORMとデータアクセス (Exposed)

### Q4. Exposedのような「型安全なDSL（ドメイン特化言語）」を持つORMを使用するメリットとして、**正しくない**ものはどれ？

- A) コンパイル時にSQLの構文ミスや型不整合（文字列カラムに数値を入れようとする等）を検知できる。
- B) IDEの補完機能が効くため、カラム名などを覚えなくても開発しやすい。
- C) 生のSQLを書くよりも実行速度が劇的に速くなる。
- D) リファクタリング（カラム名の変更など）をした際、修正が必要な箇所がコンパイルエラーとして即座にわかる。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
**ORMのメリットは「開発効率」と「保守性」**であり、実行速度ではありません。
むしろ、KotlinのコードをSQLに変換するオーバーヘッドがあるため、理論上は最適化された生のSQLよりわずかに遅くなる可能性があります（通常は無視できるレベルですが）。
A, B, D はExposed導入の主要なメリットです。

</details>

---

### Q5. 以下のコード（アンチパターン）の問題点は何ですか？

```kotlin
// "2026-01" のレポートを取得したい
val reports = transaction {
    ReportsTable.selectAll() // ① 全件取得
        .filter { it[ReportsTable.month] == "2026-01" } // ② メモリ上でフィルタ
        .map { ... }
}
```

- A) `transaction` ブロックの中で実行しているため、デッドロックが発生する。
- B) `selectAll()` でDB内の全データを取得・転送してからアプリ側で選別しているため、データ量が増えるとメモリ不足や極端な速度低下を招く。
- C) `filter` 関数はKotlin標準ライブラリではないため、コンパイルエラーになる。
- D) 特に問題はない。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
これは **「全件取得のアンチパターン」** です。
DBには「条件に合うデータだけを効率よく探す機能（インデックス）」があります。
しかし、このコードでは `selectAll()` で**全てのデータ**をDBからアプリサーバーに転送させ、その後にアプリのメモリ上で `filter` しています。データが数万件になるとアプリがクラッシュする原因になります。

**正しい実装:**
```kotlin
ReportsTable.select { ReportsTable.month eq "2026-01" } // WHERE句としてSQLが発行される
```

</details>

---

### Q6. Exposedにおける `object ReportsTable : Table("reports")` の定義と `data class Report` の違いについて適切な説明は？

- A) `ReportsTable` はDBのスキーマ（設計図）を表しシングルトンである。`Report` は実際のデータ1件分を表すインスタンスである。
- B) `ReportsTable` は読み取り専用、`Report` は書き込み専用である。
- C) どちらも同じものであり、好みの書き方を選べば良い。
- D) `ReportsTable` はクライアントに返すデータ、`Report` はDBに保存するデータである。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
Exposedではテーブル定義を `object`（シングルトン）として定義し、カラムの型や制約を記述します。これは静的な「枠組み」です。
対して `Report` クラス（Entity）は、その枠組みの中に入っている具体的なデータ（行）を保持するための入れ物です。
Room（Android）の `@Entity` クラスが両方の役割を兼ねているのと対照的です。

</details>

---

## 📚 セクション3: アプリケーション設計とDI (Koin)

### Q7. Ktorアプリで「Dependency Injection (DI)」パターンや Koin を導入する主な目的は？（最も適切なものを2つ選択）

1. アプリケーションの起動時間を短縮する。
2. コンポーネント間の結合度を下げ、`Repository` などをモック（偽物）に差し替えてテストしやすくする。
3. データベースの接続情報を暗号化する。
4. `Route`（コントローラー）がデータアクセスの詳細を知らなくて済むようにし、責務を分離する。

- A) 1 と 3
- B) 2 と 4
- C) 1 と 2
- D) 3 と 4

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
DIの主目的は **「疎結合（Decoupling）」** と **「テスト容易性（Testability）」** です。
Routeが `ReportRepositoryImpl` を直接 `new` してしまうと、DBを使わないテストを書くことが難しくなります。
DIを使えば、テスト時は「メモリ上にデータを保存するだけの偽Repository」を注入するといったことが簡単になります。

</details>

---

### Q8. Koinの定義において、`ReportRepository` のようなステートレス（状態を持たない）なクラスに適したスコープ定義は？

```kotlin
val appModule = module {
    // ここに入るのは？ <ReportRepository> { ReportRepositoryImpl() }
}
```

- A) `factory` （要求されるたびに新しいインスタンスを作成）
- B) `single` （アプリ起動中、常に同じ1つのインスタンスを使い回す）
- C) `viewModel` （画面回転などで破棄されるまで保持）
- D) `scoped` （特定のリクエスト期間中のみ保持）

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
Repository自体がデータ（状態）を持たず、DBへのアクセス機能を提供するだけであれば、インスタンスは1つあれば十分です。
これを **Singleton（シングルトン）** パターンと呼びます。
`factory` にすると、リクエストのたびに無駄にインスタンス生成が行われメモリ効率が悪くなります。

</details>

---

## 📚 セクション4: データ整合性とトランザクション

### Q9. 次のシナリオのうち、**必ず「トランザクション」内で実行すべき**ものはどれ？

- A) ユーザー一覧を取得し、その件数をログに出力する。
- B) ユーザーがレポートを投稿した際、「レポートテーブルへの保存」と「ユーザーの合計投稿数のカウントアップ」を別々のテーブルに対して行う。
- C) 外部API（天気予報など）を叩いて、結果をそのままクライアントに返す。
- D) アプリの起動時に設定ファイルを読み込む。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
**トランザクション**は「複数の更新操作を不可分な（分けられない）1つの処理」として扱う仕組みです。
Bの場合、もし「レポート保存」だけ成功して「カウントアップ」に失敗すると、データに矛盾（不整合）が生じます。
トランザクションを使えば、片方が失敗した時点で**両方ともなかったこと（ロールバック）**にして、整合性を保てます。

</details>

---

### Q10. サーバーサイド開発において、データのID（UUIDなど）や作成日時（createdAt）を決定・生成すべき場所は？

- A) **クライアント（Androidアプリ）側**: アプリがIDを生成してPOSTする。サーバーはそれをそのまま保存する。
- B) **サーバー（Repository/DB）側**: サーバーがデータを受け取った時点で生成する。
- C) **ユーザー入力**: ユーザーにIDを入力させる。
- D) **どこでも良い**: 開発者の好みで決める。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
**信頼できる唯一の情報源（Single Source of Truth）**はサーバーであるべきです。
クライアント側で生成すると以下のようなリスクがあります：
- クライアントの時計がズレている可能性がある（未来の日付で登録されるなど）。
- 悪意あるユーザーがIDを操作して重複させたり、不正なフォーマットで送ってくる可能性がある。
- 複数のクライアント（iOS, Webなど）がある場合、ロジックが分散する。

</details>

---

## 📚 セクション5: APIレスポンス設計

### Q11. Entity（内部モデル）と DTO（データ転送用オブジェクト）を分ける理由として、**誤っている**記述は？

- A) 内部では `LocalDate` 等のリッチな型を使いたいが、JSONにはそれらを文字列等に変換して載せる必要があるため。
- B) ユーザーの「パスワードハッシュ」など、内部では必要だがクライアントには絶対に見せてはいけないフィールドを除外するため。
- C) アプリ側の画面仕様が変わってレスポンスの形を変える必要が出た時、DB設計まで影響を受けないようにするため（変更の緩衝材）。
- D) コードの行数を増やして、プロジェクトの規模を大きく見せるため。

<details>
<summary>答えを見る</summary>

**正解: D**

**解説:**
Entity/DTOの分離はボイラープレート（決まり切ったコード）を増やしますが、それ以上のメリット（**セキュリティ、責務の分離、変更への強さ**）があります。
特にAPI開発では、DBのカラム構造とAPIのレスポンス構造が完全に一致し続けることは稀です。

</details>

---

### Q12. 以下の操作に対するHTTPステータスコードの組み合わせとして、最も適切なものは？

1. `POST /reports` で新規作成に成功した。
2. `DELETE /reports/{id}` で削除に成功し、特に返すデータがない。
3. `PUT /reports/{id}` で更新しようとしたが、指定されたIDが存在しなかった。

- A) 1: `200 OK`, 2: `200 OK`, 3: `500 Server Error`
- B) 1: `201 Created`, 2: `204 No Content`, 3: `404 Not Found`
- C) 1: `200 OK`, 2: `404 Not Found`, 3: `400 Bad Request`
- D) 1: `201 Created`, 2: `200 OK`, 3: `403 Forbidden`

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
Web APIの標準的な作法（セマンティクス）です。
- **201 Created**: リソースの作成成功。通常 `Location` ヘッダーに作成されたリソースのURLを含めます。
- **204 No Content**: 処理は成功したが、レスポンスボディには何もない（削除成功時によく使われる）。
- **404 Not Found**: クライアントが要求したリソースが存在しない。

</details>

---

## 🏆 完了目安

このチェックリストで **10問以上** 正解できれば、Phase 3.2 のアーキテクチャ設計を十分に理解しています。
間違えた項目は、もう一度解説を読み、実際のコードでどのように実装されているか確認してみてください。
