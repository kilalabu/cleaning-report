# Phase 3.3: 認証 & 認可 (JWT) 理解度チェックリスト

Phase 3.3（Supabase Auth JWT検証、認証・認可の実装）に関する**本質的な概念と仕組み**を理解するための問題集です。
セキュリティに関わる重要なパートですので、仕組みを確実に理解しましょう。

---

## 📚 セクション1: 認証の基礎とJWT

### Q1. 認証（Authentication）と認可（Authorization）の違いとして正しい説明は？

- A) **認証**は「ユーザーが誰か」を確認すること、**認可**は「そのユーザーに何の権限があるか」を確認すること。
- B) **認証**はサーバー側の処理、**認可**はクライアント側の処理。
- C) 両者は完全に同じ意味であり、文脈によって使い分けられるだけである。
- D) **認証**はパスワードを使うもの、**認可**は指紋など生体情報を使うもの。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
- **認証 (Authentication)**: Identity（身元）の確認。「あなたは誰ですか？」
    - 例: ログイン、身分証の提示。
- **認可 (Authorization)**: Permission（権限）の確認。「あなたは何をして良いですか？」
    - 例: このファイルを削除して良いか？ 管理者ページにアクセスして良いか？
Ktorでは、まずJWTで**認証**し、その後にそのユーザーIDを使ってビジネスロジックで**認可**を行います。

</details>

---

### Q2. Ktorサーバーで「Supabase AuthのJWT」を検証する際、Supabaseのサーバーに毎回問い合わせる必要があるか？

- A) はい、Supabaseにトークンを送って「これは正しいですか？」と毎回聞く必要がある（イントロスペクション）。
- B) いいえ、JWTは「署名」を含んでいるため、事前に取得した**公開鍵**を使うことで、Ktorサーバー単独で検証できる。
- C) はい、ただしキャッシュを使えば5分に1回で済む。
- D) いいえ、JWTは暗号化されていないので誰でも検証なしに信用して良い。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
これがJWT（JSON Web Token）の最大のメリットです。
Supabaseは秘密鍵で署名し、その対となる**公開鍵（JWK）**を公開しています。
Ktorサーバーはこの公開鍵を持っていれば、Supabaseに通信することなく「このトークンはSupabaseが発行した本物である」と数学的に証明（検証）できます。これにより高速なAPIレスポンスが可能になります。

</details>

---

### Q3. JWT (JSON Web Token) の構造について、セキュリティ上**注意すべき点**は？

- A) Base64でエンコードされているだけ（暗号化ではない）なので、ペイロードに**パスワードなどの機密情報を含めてはいけない**。
- B) ヘッダー、ペイロード、署名の3部構成だが、署名部分は削除してもサーバーは受け入れてしまう。
- C) 一度発行されたJWTは、サーバー側から強制的に無効化（Revoke）することが非常に簡単である。
- D) JWTはファイルサイズが大きいため、モバイル通信では使わない方が良い。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
JWTの中身（Payload）は `eyJ...` のような文字列に見えますが、ただの Base64Url エンコードです。
デコードすれば誰でも中身（ユーザーIDやメアドなど）を読めます。
そのため、クレジットカード番号や生パスワードなどは絶対に入れてはいけません。
逆に、改ざん（書き換え）に対しては「署名」によって強力に保護されています。

</details>

---

## 📚 セクション2: 実装メカニズム (Ktor)

### Q4. `JwkProviderBuilder` を使って公開鍵を取得する際、`.cached(...)` や `.rateLimited(...)` を設定する主な理由は？

- A) Supabaseの公開鍵は1秒ごとに変わるため、頻繁に更新する必要があるから。
- B) セキュリティのために、公開鍵を暗号化して保存する必要があるから。
- C) 毎リクエストでSupabaseのJWKsエンドポイント（URL）にアクセスすると遅延が発生し、かつSupabase側のレート制限（API制限）に引っかかる可能性があるから。
- D) Ktorの仕様で、キャッシュ設定が必須だから。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
公開鍵（JWK）はめったに変更されません。
リクエストのたびに `https://.../jwks.json` に取りに行くと、通信のオーバーヘッドでAPIが遅くなり、さらにアクセス過多でSupabaseからブロックされるリスクがあります。
一度取得したらメモリに**キャッシュ**し、数分〜数時間は使い回すのが鉄則です。

</details>

---

### Q5. 認証フローにおける `verifier` と `validate` の役割分担として正しいのは？

- A) `verifier` は署名が正しいかを数学的にチェックし、`validate` はそのトークンの中身（有効期限やユーザーの状態）を見て認証の合否を最終判断する。
- B) `verifier` はパスワードを確認し、`validate` はメールアドレスを確認する。
- C) `verifier` はクライアント側で行い、`validate` はサーバー側で行う。
- D) 両者は同じ機能なので、どちらか片方だけ実装すれば良い。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
KtorのJWT認証は2段階で行われます。
1.  **`verifier`**: 暗号学的なチェック。「このトークンは改ざんされていないか？ 発行者は正しいか？」
2.  **`validate`**: ロジック的なチェック。「署名は正しいが、有効期限は切れていないか？ BANされたユーザーではないか？」
`validate` ブロックで `null` を返すと、署名が正しくても認証失敗（401）にできます。

</details>

---

### Q6. `validate` ブロック内で `JWTPrincipal(credential.payload)` を返すことの意味は？

- A) 認証に失敗したことをKtorに伝える。
- B) 認証に成功し、このリクエストの「実行者情報（Principal）」としてペイロードを登録する。以降、`call.principal()` で取り出せるようになる。
- C) 新しいJWTを発行してクライアントに返す。
- D) データベースにユーザー情報を保存する。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
`validate` が非nullの値（Principal）を返すと、Ktorはそのリクエストを「認証済み」と扱います。
返されたオブジェクト（`JWTPrincipal`）は `call` のコンテキストに保存され、後続の処理（ルートハンドラなど）で `call.principal<JWTPrincipal>()` を呼び出すことで、**「今アクセスしてきているのは誰か（ユーザーIDなど）」** を取り出すことができます。

</details>

---

## 📚 セクション3: セキュリティ設計

### Q7. 自分のデータを更新するAPI (`PUT /reports/{id}`) で、「他人のデータを書き換えられない」ようにするための正しい実装は？

- A) クライアント（アプリ）側でチェックしているので、サーバー側では特にチェックしなくて良い。
- B) JWTの検証（認証）が通れば、どのデータでも自由に触らせて良い。
- C) JWTから取得した `userId`（実行者）と、更新対象データの `userId`（所有者）が一致するかをサーバー側で確認する。
- D) リクエストのBodyに含まれる `user_id` と、更新対象データの `user_id` を比較する。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
これが**認可（Authorization）**のステップです。
「ログインしている（認証OK）」ことと、「そのデータに触っていい（認可OK）」ことは別です。
絶対に**クライアントから送られてきたID**（Dのケース）を信用してはいけません（攻撃者は自由にJSONを書き換えられるため）。
必ず**検証済みのJWT（Principal）**から取り出したIDを「正」として扱う必要があります。

</details>

---

### Q8. Ktorでの認証に加え、データベース（Postgres）側でも RLS (Row Level Security) を設定すべき理由は？（多層防御）

- A) Ktorの処理速度を上げるため。
- B) KtorだけではSQLインジェクションを防げないから。
- C) 万が一Ktorの実装にバグがあったり、設定ミスで認証をすり抜けられた場合でも、データベース層で最終的にデータを守るため。
- D) RLSを設定しないとSupabaseが課金されるため。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
セキュリティの世界では「**多層防御 (Defense in Depth)**」が基本です。
アプリ層（Ktor）でチェックするのは当然ですが、人間はミスをします（認可ロジックの書き忘れなど）。
DB層（RLS）でも「自分のIDの行しか `UPDATE` できない」というルールを強制しておけば、アプリ側のミスで穴が開いても、被害を最小限に食い止めることができます。

</details>

---

## 🏆 完了目安

このチェックリストで **6問以上** 正解できれば、Phase 3.3 の認証・認可に関する実装意図は十分に理解できています。
特に **「JWT検証は公開鍵で行う（Supabaseに聞かない）」「認証と認可は別ステップ」「IDは必ずJWTから取る」** という3点は非常に重要です。
