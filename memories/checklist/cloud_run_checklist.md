# Cloud Run & サーバーレスアーキテクチャ 理解度チェックリスト (Deep Dive)

Google Cloud Run をはじめとする「サーバーレスコンテナ」の仕組みと、それに適したアプリケーション設計（Twelve-Factor App）を深く理解するための問題集（全11問）です。
インフラを意識しない開発（NoOps）の世界へ踏み込みましょう。

---

## 📚 セクション1: サーバーレスの特性

### Q1. Cloud Runにおける「サーバーレス」という用語の技術的な定義として最も適切なのは？

- A) 物理的なサーバーハードウェアが存在せず、コードがブロックチェーン上で分散実行される仕組み。
- B) 特定のプログラミング言語（Node.jsやPython）しか実行できない環境。
- C) 利用者がサーバー（インスタンス）のプロビジョニング、管理、スケーリングを行う必要がなく、クラウドプロバイダがリクエスト負荷に応じて動的にリソースを割り当てる実行モデル。
- D) サーバーOSへのSSHログインが可能だが、root権限だけが剥奪されている状態。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
物理的にはサーバーは存在しますが、それを「意識しなくて良い」のがサーバーレスです。
「アクセスが急増したからサーバーを増やそう」「深夜だから減らそう」「OSのアップデートしなきゃ」といった従来のインフラエンジニアの仕事を、プラットフォームが全自動で行います。
開発者は「コンテナ１個」を作ることに集中できます。

**❌ 不正解の解説:**
- **A**: サーバー実体はGoogleのデータセンターにある物理マシンです。ブロックチェーンではありません。
- **D**: むしろ逆で「Dockerコンテナさえ作れればどんな言語でも動く（Go, Kotlin, Rustなど）」のがCloud Runの特徴です。

---
💡 **さらに深掘り: 「マネージドサービス (Managed Service)」とは？**
直訳すると「管理されたサービス」。
*   **アンマネージド (VPSなど)**: 土地と家だけ貸すから、掃除も修理も警備も自分でやってね。（自由だが大変）
*   **マネージド (Cloud Runなど)**: ホテルのように、掃除もベッドメイクも警備も全部やるから、あなたはただ泊まる（コードを動かす）だけでいいよ。（制限はあるが楽）

</details>

---

### Q2. Cloud Runの「課金モデル」として正しいのは？

- A) Google Cloudのアカウントを作成した時点で基本料金が発生する。
- B) インスタンスを作成した時点から削除するまで、毎月定額（サブスクリプション）で課金される。
- C) コンテナイメージの保存容量（GB単位）のみに対して課金される。
- D) リクエストを処理している時間（CPU/メモリ使用量）に対して 100ミリ秒単位で課金され、リクエストがない待機時間は（最小インスタンス設定がない限り）無料である。

<details>
<summary>答えを見る</summary>

**正解: D**

**解説:**
これが Cloud Run 最大のメリットの一つです。
従来のVM（Compute Engine）は起動している限り24時間課金されますが、Cloud Runは「リクエストが来てコンテナが動いている間」だけ課金されます。

**❌ 不正解の解説:**
- **B**: これは GCE (Google Compute Engine) や AWS EC2 の課金モデルです。起動しっぱなしだとお金がかかります。
- **C**: イメージ保存料は Artifact Registry にかかりますが、微々たるものです。メインの課金は計算リソース（CPU/メモリ）です。

</details>

---

### Q3. 「ステートレス（無状態）であるべき」という制約の、より深い意味は？

- A) HTTPプロトコルではなく、WebSocketのみを使用しなければならない。
- B) 一度デプロイしたアプリケーションのソースコードは変更してはいけない。
- C) リクエスト間で状態を共有する場合、コンテナ内部のメモリやローカルファイルシステムに依存せず、必ず外部のデータストア（DB, Redis等）を使用しなければならない。
- D) データベースへの接続（コネクションプール）を保持してはいけない。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
Cloud Runでは、リクエストAを処理したコンテナと、次のリクエストBを処理するコンテナが同じとは限りません。
「リクエストAで計算した結果を変数 `x` に保存し、リクエストBで `x` を使う」というコードを書くと、別のコンテナに飛ばされたときにバグります。

**❌ 不正解の解説:**
- **D**: むしろ逆です！コネクションプールはパフォーマンスのために保持・再利用すべきです。ただし、接続情報（URL等）自体は環境変数化します。
- **B**: それは「イミュータブル」の話であり、ステートレスとは少し違います。

---
💡 **さらに深掘り: 「不滅のペット」ではなく「使い捨ての家畜」**
*   **ペット (従来のサーバー)**: 名前をつけて手当てして長生きさせる。
*   **家畜 (クラウドのコンテナ)**: 個別の名前はなく、調子が悪ければすぐ入れ替える。

</details>

---

## 📚 セクション2: ライフサイクルとパフォーマンス

### Q4. 「コールドスタート」が発生するメカニズムと、その対策として正しい組み合わせは？

- A) インスタンス数0の状態からリクエストが来たため、コンテナの起動・アプリの初期化処理待ち時間が発生している。対策: `min-instances` を設定するか、Startup Probe を最適化する。
- B) ネットワーク帯域が不足しているため。対策: CDNを導入する。
- C) CPU温度が下がりすぎたため。対策: サーバー室のエアコン設定温度を上げる。
- D) データベース接続が切断されたため。対策: コネクションプールを無効化する。

<details>
<summary>答えを見る</summary>

**正解: A**

**解説:**
Cloud Runはアクセスがないとインスタンス数を0にします（スケール・トゥ・ゼロ）。
次にリクエストが来ると、OS起動→コンテナ起動→アプリ初期化が走り、数秒〜十数秒待たされます（コールドスタート）。

**❌ 不正解の解説:**
- **D**: DB接続とは無関係です。コンテナ自体がまだ起きていない状態の話です。
- **C**: 物理的な温度の話ではありません。

</details>

---

### Q5. Cloud Runの「同時実行数 (Concurrency)」設定のデフォルト値80の意味は？

- A) 同時に接続できるデータベースのセッション数が80である。
- B) 1つのコンテナインスタンスで、マルチスレッド等を用いて同時に最大80個のリクエストを並列処理できる。
- C) 1秒間あたりのリクエスト数（RPS）が80を超えるとエラーになる。
- D) プロジェクト全体で起動できるコンテナインスタンスの上限が80台である。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
Lambdaなどは通常「1インスタンス = 1リクエスト」なので、100リクエスト来たら100個起動します。
Cloud Runは1つのコンテナで複数のリクエストをマルチスレッドで捌けます。

**❌ 不正解の解説:**
- **D**: それは「最大インスタンス数 (`max-instances`)」の設定です。Concurrencyとは別の概念です。
- **C**: 80を超えたら、新しいインスタンス（2台目）が自動的に立ち上がって処理します（エラーにはなりません）。

</details>

---

### Q6. アプリケーションログ（標準出力 `stdout` / 標準エラー `stderr`）のベストプラクティスは？

- A) ログファイル（`app.log`）に出力し、コンテナ終了時にSidecarコンテナを使ってS3等へアップロードする。
- B) ログはパフォーマンス低下の原因になるため、本番環境では一切出力しない。
- C) アプリケーションから直接Logging APIを叩いてログを送信する（非同期送信）。
- D) 構造化ログ（JSON形式）として標準出力に書き出し、Cloud Loggingエージェントに自動収集させる。

<details>
<summary>答えを見る</summary>

**正解: D**

**解説:**
コンテナデザインパターンの定石です。
標準出力にJSONで吐き出せば、Google Cloud側がそれをパースし、検索可能なログとして自動保存してくれます。

**❌ 不正解の解説:**
- **A**: 非常に手間がかかる古いやり方です。Cloud Runでは標準出力（stdout）に出すだけで十分です。
- **C**: API呼び出しのコスト（遅延・複雑さ）が発生します。標準出力に書く方が高速で疎結合です。

</details>

---

## 📚 セクション3: 設定とセキュリティ

### Q7. DBのパスワードなどの機密情報（Secret）を扱う際、セキュリティと運用効率の観点から最も推奨される方法は？

- A) 環境変数として直接コンテナ定義（YAML）に平文で埋め込む。
- B) Google Secret Managerに保存し、Cloud Run実行時に環境変数として安全に注入（参照）させる。
- C) 独自の暗号化ロジックで暗号化し、ソースコード内にハードコードする。
- D) Dockerイメージビルド時にファイルとして含め、アクセス権限を 600 に設定する。

<details>
<summary>答えを見る</summary>

**正解: B**

**解説:**
- **Secret Manager** は暗号化された金庫のようなサービスです。
Cloud Runと連携させることで、アプリ起動時にのみ環境変数として安全に渡すことができます。

**❌ 不正解の解説:**
- **A**: 環境変数はCloud Console画面などで見えてしまうことが多く、またGit管理下のYAMLファイルに書くと漏れるリスクが高いです。
- **D**: イメージ内にあるファイルは、イメージを入手できる人なら誰でも読めてしまいます。絶対にやってはいけません。

</details>

---

### Q8. Cloud Runの「サービスアカウント (Service Account)」の役割として適切なのは？

- A) 開発者がGoogle Cloud ConsoleにログインするためのIDとパスワード。
- B) 課金情報を管理するための専用アカウント。
- C) コンテナ内部のLinuxユーザー（rootやnobodyなど）のこと。
- D) アプリケーションの実行主体のアイデンティティを表し、他のGoogle Cloudリソース（Storage, Firestore等）へのアクセス権限を制御するためのもの。

<details>
<summary>答えを見る</summary>

**正解: D**

**解説:**
Cloud Runで動くアプリは、この「サービスアカウント」という名札をぶら下げて動きます。
「この名札をつけたアプリは、データベース(A)には触っていいけど、ストレージ(B)は読んじゃだめ」といった権限管理（IAM）を行うために必須の概念です。

**❌ 不正解の解説:**
- **A**: それは「ユーザーアカウント」です。サービスアカウントは「ロボット用」です。

</details>

---

### Q9. Cloud Runの「トラフィック分割（Traffic Splitting）」機能の主な用途は？

- A) 複数のリージョン（東京と大阪など）に均等にリクエストを振り分けるため（負荷分散）。
- B) 無料枠の範囲内にトラフィックを抑えるため。
- C) 新しいリビジョン（バージョン）をデプロイした際、例えば「10%のユーザーのみ」に新版を提供し、エラー率などを監視してから全ユーザーに適用する（カナリアリリース）ため。
- D) モバイルとPCでアクセスするバックエンドサーバーを切り替えるため。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
「リビジョンV1に90%、V2に10%」といった設定が管理画面のスライダーひとつで可能です。
これにより、いきなり全員にバグのある新版を配って大炎上するリスクを避けられます。

**❌ 不正解の解説:**
- **A**: リージョン間の振り分けは、もっと前段の「ロードバランサ」の仕事です。Cloud Run自体はリージョナル（特定の地域内）なリソースです。

</details>

---

### Q10. Cloud RunからVPC内部のDB（プライベートIPのみ）に接続するために必要な構成は？

- A) Cloud RunとDBを同じゾーン（例: asia-northeast1-a）に配置するだけで自動的に繋がる。
- B) DB側のファイアウォールで `0.0.0.0/0` からの接続を許可する。
- C) Cloud Runの設定で「Serverless VPC Access コネクタ」を使用するか、「Direct VPC Egress」を有効にして、トラフィックをVPCネットワークへルーティングする。
- D) DBにパブリックIPアドレスを付与し、SSL接続を強制する。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
Cloud Runから直接VPC内のDBは見えません。
**VPCコネクタ** という「直通トンネル」を工事することで、Cloud RunからプライベートIPアドレスを使ってDBにアクセスできるようになります。

**❌ 不正解の解説:**
- **B**: **危険です！** `0.0.0.0/0` は「全世界からの接続許可」を意味します。絶対にやってはいけません。
- **D**: パブリックIPを使えば繋がりますが、DBをインターネットに晒すことになるため、セキュリティリスクが増大します（推奨されません）。

---
💡 **さらに深掘り: 「VPC」って何？なぜ「トンネル」が必要？**

**VPC (Virtual Private Cloud)** は、クラウド上に作る**「あなた専用の貸切LAN（家の敷地）」**です。
公道（インターネット）とは隔離されており、部外者は入れません。データベース（金庫）はこの敷地内に置くのが定石です。

```
[ インターネット (公道) ]          [ VPC (家の敷地) ]
       │                                  │
  [ Cloud Run ] ─────────x 壁 x──────── [ DB ]
    (外の人)            (入れない)      (中の人)
```

しかし、Cloud Run自体はデフォルトで「VPCの外（Googleの共有地）」にいます。
そのままでは家の中のDBにアクセスできません。

そこで**「VPCコネクタ」**を使います。
これは、外にいるCloud Runから、家の敷地内（VPC）まで**「専用の地下トンネル」**を掘るようなイメージです。
このトンネルを通ることで、インターネットを経由せず、安全にDBまで到達できるようになります。

</details>

---

### Q11. `PORT` 環境変数を無視して、アプリ内でハードコードされたポート（例: 3000）でリッスンした場合どうなるか？

- A) 自動的に8080番ポートにリダイレクトされる。
- B) Cloud Runが自動的にポート3000を検出し、トラフィックを転送してくれる。
- C) コンテナは起動するが、Cloud Runからのヘルスチェック（デフォルト設定ポートへのアクセス）に応答できず、デプロイが「失敗」としてロールバックされる。
- D) Dockerfileの `EXPOSE 3000` があれば動作する。

<details>
<summary>答えを見る</summary>

**正解: C**

**解説:**
**超重要**かつ頻出のハマりポイントです。
クラウド基盤側が「君はこのポートを使ってね」と指定してくるので、アプリ側はそれに従う義務があります。
無視すると「接続拒否」となりデプロイ失敗します。

**❌ 不正解の解説:**
- **D**: **`EXPOSE` はただのドキュメント（メモ書き）です。** これを書いただけでは何の機能も動きません。ポートマッピングも自動では行われません。

</details>

---

## 🏆 完了目安

このチェックリストで **8問以上** 正解できれば、Cloud Runの特性を活かした設計・運用ができるレベルです。
特に **「ステートレス性（Q3）」「コールドスタート対策（Q4）」「PORT環境変数（Q11）」** は、アプリ開発者がコードを書く際に直接影響する最重要項目です。
