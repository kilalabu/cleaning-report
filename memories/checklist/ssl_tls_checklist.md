# SSL/TLS 理解度チェックリスト

このチェックリストは、[新人エンジニアのための今度こそ理解するSSL/TLS超入門](https://zenn.dev/collabostyle/articles/ec7604c7468b84) の内容に基づき、SSL/TLSの仕組み、役割、ハンドシェイクのフローなどの理解度を確認するために作成されました。

## 前提知識と学習のポイント
- **暗号化の3要素**: 盗聴防止（機密性）、改ざん防止（完全性）、なりすまし防止（認証）。
- **ハイブリッド暗号**: 公開鍵暗号（鍵交換用）と共通鍵暗号（通信用）の組み合わせ。
- **証明書とPKI**: 信頼できる第三者（CA）による署名の仕組み。
- **TLSバージョン**: 記事ではTLS 1.2をベースに解説されていますが、現在はより高速で安全なTLS 1.3が主流になりつつあります（本問題集の解説で補足します）。

---

## 第1部: 基礎概念 (単数/複数選択)

### Q1. SSL/TLSが提供する「3つの守るもの」として**誤っている**ものはどれですか？ (単数選択)
- [ ] A. 通信内容の暗号化（盗聴防止）
- [ ] B. 通信速度の高速化（レイテンシ削減）
- [ ] C. 通信内容の完全性（改ざん検知）
- [ ] D. 接続先サーバーの認証（なりすまし防止）

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
SSL/TLSの主な目的はセキュリティ（機密性、完全性、認証）の確保であり、通信速度の向上自体が目的ではありません。むしろ暗号化処理やハンドシェイクのオーバーヘッドにより、生のHTTPよりわずかに遅くなる要因となります（ただしHTTP/2やTLS 1.3などで高速化の工夫はなされています）。
</details>

### Q2. ブラウザのアドレスバーに「鍵マーク」や「https://」が表示されているWebサイトについて、正しい説明はどれですか？ (単数選択)
- [ ] A. そのサイトは絶対にウイルスに感染していない安全なサイトである。
- [ ] B. そのサイト運営会社は信頼できる大企業であると国が保証している。
- [ ] C. 自分のPCとサーバー間の通信経路が暗号化されており、接続先のサーバーが証明書のドメイン所有者であることを示している。
- [ ] D. 入力したクレジットカード情報は、サーバーに到達した後も永遠に暗号化されたまま保存されることが保証されている。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: C**

**解説:**
HTTPSは「通信経路の安全性」と「接続先の本人性」を保証するものであり、**サイトの中身の安全性（ウイルスがないか、詐欺業者でないか）を保証するものではありません**。
また、サーバー到達後のデータの扱いはサーバー側の実装に依存するため、Dも間違いです。
</details>

### Q3. SSL/TLS通信において「共通鍵暗号」と「公開鍵暗号」を使い分ける理由として最も適切なものはどれですか？ (単数選択)
- [ ] A. 公開鍵暗号の方が処理が高速なので、すべての通信を公開鍵暗号で行いたいが、技術的に不可能だから。
- [ ] B. 共通鍵暗号は処理が高速だが鍵の配送に課題があり、公開鍵暗号は処理は遅いが安全に鍵を共有できるため、両方の長所を組み合わせている。
- [ ] C. サーバーからクライアントへの送信は共通鍵、クライアントからサーバーへの送信は公開鍵を使う決まりになっているから。
- [ ] D. 現在のスーパーコンピュータでも解読できないのは共通鍵暗号だけだから。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
これを「ハイブリッド暗号方式」と呼びます。
- **公開鍵暗号**: 重い計算が必要だが、安全に鍵を交換できる（ハンドシェイクで使用）。
- **共通鍵暗号**: 処理が高速（通信データの暗号化で使用）。
両者のいいとこ取りをしています。
</details>

---

## 第2部: 重要用語と定義 (用語一致)
**※ここが理解できていないと、以降の解説を読むのが難しくなります。**

### Q4. 「SSL (Secure Sockets Layer)」の説明として正しいものはどれですか？ (単数選択)
- [ ] A. ネットスケープ社が開発した暗号化プロトコルの名称。現在は脆弱性が見つかっているため使用は推奨されていないが、名称だけが慣習として残っている。
- [ ] B. サーバーの処理速度を高速化するためのキャッシュ技術の名称。
- [ ] C. 最新の暗号化プロトコルの正式名称であり、TLSよりも新しい規格。
- [ ] D. データベースにアクセスするための問い合わせ言語。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A**

**解説:**
**A**: 正解。SSLは1990年代に開発されましたが、SSL 3.0までに多くの脆弱性が見つかりました。現在は後継規格である **TLS** が使われていますが、言葉として「SSL証明書」「SSL通信」などが定着して使われています。
</details>

### Q5. 「TLS (Transport Layer Security)」の説明として正しいものはどれですか？ (単数選択)
- [ ] A. 通信経路や配送手段に関わらず、データの安全性を保証する物流システムの規格。
- [ ] B. SSLの後継として標準化された、現在のインターネットで利用されている暗号化プロトコル。
- [ ] C. データを圧縮して通信量を削減するためのプロトコル。
- [ ] D. 文字数制限のあるSNSでデータを送るための短縮プロトコル。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**B**: 正解。SSLをベースにIETFで標準化されたのがTLSです。現在はTLS 1.2 や TLS 1.3 が標準的に利用されています。記事の中でも解説されている通り、実質的に「SSL/TLS」はセットで扱われますが、技術的な実体はTLSです。
</details>

### Q6. 「HTTPS (HyperText Transfer Protocol Secure)」の説明として正しいものはどれですか？ (単数選択)
- [ ] A. HTTPとは全く異なる、動画配信専用の新しい通信プロトコル。
- [ ] B. 通常のHTTP通信を、SSL/TLSプロトコルで暗号化して行う仕組みのこと。
- [ ] C. HTMLファイルを作成するための、プログラミング言語の一種。
- [ ] D. 高速なインターネット回線を使用していることを示すマーク。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**B**: 正解。HTTPSは新しいプロトコルではなく、既存の「HTTP」の下層に「SSL/TLS」という暗号化のトンネルを作って通信する仕組みです。これにより、HTTPのやり取りが全て暗号化されます。
</details>

### Q7. 「Cipher Suite (暗号スイート)」の説明として正しいものはどれですか？ (単数選択)
- [ ] A. 複数のサーバー証明書をひとまとめにしてアーカイブ圧縮したファイル。
- [ ] B. 「鍵交換」「署名」「暗号化」「ハッシュ」などのアルゴリズムの組み合わせセット。通信開始時にどれを使うか合意する。
- [ ] C. サーバーの秘密鍵を安全に保管するためのハードウェア。
- [ ] D. パスワードを忘れたときに使う秘密の質問セット。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**B**: 正解。記事の「ステップ① クライアントが接続を開始する」でも触れられている通り、クライアントは「使える暗号方式リスト」を送り、サーバーがその中から一つを選びます。この組み合わせを暗号スイートと呼びます。
</details>

---

## 第3部: デジタル証明書と認証 (並び替え・仕組み)

### Q11. サーバー証明書が正当であることをブラウザが検証する際の流れとして、正しい順序に並び替えてください。 (並び替え)
1. 証明書の署名部分を、ブラウザに保存されているルート証明書（または中間CA）の「公開鍵」で復号する。
2. 復号して出てきたハッシュ値と、証明書本文から計算したハッシュ値を比較する。
3. サーバーから送られてきた証明書を受け取る。
4. 一致すれば「改ざんされておらず、信頼できるCAによって署名された」と判断する。

- [ ] A. 3 -> 1 -> 2 -> 4
- [ ] B. 3 -> 2 -> 1 -> 4
- [ ] C. 1 -> 3 -> 2 -> 4
- [ ] D. 3 -> 1 -> 4 -> 2

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A**

**解説:**
検証プロセス（デジタル署名の検証）の基本フローです。
1. **受け取る**: 証明書取得。
2. **復号**: 署名にはCAの「秘密鍵」が使われているため、ペアとなる「公開鍵」で復号します。
3. **比較**: 証明書の内容（Original）をハッシュ化したものと、復号されたハッシュ値（Signature Hash）が一致するか確認し、CAが保証した内容から改ざんされていないことを確かめます。
</details>

### Q12. いわゆる「オレオレ証明書（自己署名証明書）」に関して、正しい記述をすべて選んでください。 (複数選択)
- [ ] A. 暗号化通信自体は可能であるため、盗聴を防ぐ効果はある。
- [ ] B. 第三者機関（CA）による身元確認が行われていないため、なりすましの危険性がある。
- [ ] C. 一般公開するWebサービスの本番環境で使用しても、特にセキュリティ上の問題はない。
- [ ] D. 社内の閉じた開発環境やテスト環境で、コストをかけずにHTTPSを試す目的などで使われることがある。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A, B, D**

**解説:**
- A: 正しいです。証明書が信頼できなくても暗号化自体は機能します。
- B: 正しいです。誰でも「私はGoogleです」というオレオレ証明書を作れてしまうため、ブラウザは警告を出します。
- C: 間違いです。ユーザーに「セキュリティ警告」画面を見せることになり、信頼を損なう上に、中間者攻撃のリスクも高まります。
- D: 正しいです。開発環境の用途として一般的です。
</details>

### Q13. CA（認証局）の役割として**不適切な**ものはどれですか？ (単数選択)
- [ ] A. 申請者がドメインの所有者であることを確認する（審査）。
- [ ] B. サーバーの秘密鍵をCA側で生成し、申請者にメールで送付する。
- [ ] C. 有効期限切れや失効した証明書の情報を管理する。
- [ ] D. 証明書に対して、CAの秘密鍵を使って電子署名を行う。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**サーバーの秘密鍵は絶対にサーバー管理者（申請者）以外が知ってはいけません**。
通常は申請者が自分で「秘密鍵」と「CSR（署名要求）」を作成し、CSRだけをCAに送ります。CAが秘密鍵を作る方式だと、配送途中の盗聴やCA内部犯行のリスクが生じます。
</details>

---

## 第4部: TLSハンドシェイク (フロー理解)

### Q11. TLS 1.2における標準的なハンドシェイクの**前半フェーズ（合意と証明書送付）**について、正しい順序に並び替えてください。 (並び替え)
1. サーバーは、提示されたリストから最適な暗号スイートを選び、自分の「サーバー証明書」と一緒にクライアントに送る (Server Hello)。
2. クライアントは、サーバー証明書が信頼できるCAによって署名されているか、有効期限内かなどを検証する。
3. クライアントは、自分が対応している「暗号スイート（使用可能な暗号方式のリスト）」をサーバーに送る (Client Hello)。
4. 検証に成功したら、クライアントは共通鍵の元となるデータ（プリマスターシークレット）を生成する。

- [ ] A. 3 -> 1 -> 2 -> 4
- [ ] B. 1 -> 3 -> 2 -> 4
- [ ] C. 3 -> 2 -> 1 -> 4
- [ ] D. 2 -> 3 -> 1 -> 4

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A**

**解説:**
1. **Client Hello**: まずクライアントが「私はこれらの暗号語を話せます」と名乗り出ます。
2. **Server Hello**: サーバーが「じゃあこの暗号語で話しましょう」と決め、身分証（証明書）を提示します。
3. **検証**: クライアントは身分証を確認します。
4. **鍵生成**: 確認できたら、鍵の生成準備に入ります。
</details>

### Q12. ハンドシェイクの最初のステップ「ネゴシエーション（Client Hello / Server Hello）」において、クライアントとサーバーの間で話し合って**決定**される項目として正しいものをすべて選んでください。 (複数選択)
- [ ] A. 今回の通信で使用する「TLSのバージョン」（例: TLS 1.2 や 1.3）
- [ ] B. 今回の通信で使用する「暗号スイート」（例: 鍵交換はECDHE、暗号化はAES...といった組み合わせ）
- [ ] C. ログインするためのユーザーIDとパスワード
- [ ] D. 暗号化通信に使用する「共通鍵」そのもの

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A, B**

**解説:**
最初の挨拶では「どの言葉（プロトコル・暗号方式）で話すか」を決めます。
- **A, B**: 正解。お互いが対応しているリストの中から、最も安全で新しいものをサーバーが選びます。
- **C**: これはアプリケーション層（HTTP）の話なので、TLSハンドシェイクが終わった後の話です。
- **D**: 共通鍵はまだ作れません。この挨拶の後に交換します。
</details>

### Q13. ブラウザが「サーバー証明書」を受け取った際、それを「信頼できない」として**エラーにする条件**として、正しいものをすべて選んでください。 (複数選択)
- [ ] A. 証明書の「有効期限」が切れている、またはまだ開始していない。
- [ ] B. 証明書に記載されている「ドメイン名（SAN）」と、実際にアクセスしているURLのドメイン名が一致しない。
- [ ] C. 証明書を発行（署名）したCAのルート証明書が、ブラウザのトラストストアに入っていない。
- [ ] D. 証明書のファイルサイズが 5KB 以上ある。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A, B, C**

**解説:**
証明書の検証は主にこの3点を見ます。
- **A (期限)**: パスポートの期限切れと同じです。
- **B (所有者)**: 別人のパスポートを持っていないか確認します。
    - **設定ミス**: IPアドレスでアクセスした場合や、別のサブドメイン用の証明書を誤って設定した場合によく起きます。
    - **なりすまし**: 攻撃者が通信に割り込み、自分が持っている「別のドメインの正規証明書」を提示してきたケースも見抜けます（`facebook.com` にアクセスしたのに `evil.com` の証明書が出されたら拒否します）。
- **C (発行者)**: そのパスポートの発行元（国）を信頼できるか確認します。オレオレ証明書はここで引っかかります。
- **D**: サイズは関係ありません。
</details>

### Q14. TLS 1.2ハンドシェイクの**後半フェーズ（鍵交換と通信開始）**について、正しい順序に並び替えてください。 (並び替え)
1. サーバーは受け取ったデータを自分の「秘密鍵」で復号し、共通鍵の元（プリマスターシークレット）を取り出す。
2. 双方がそれぞれ「共通鍵」を計算して生成する。ここから先の通信はすべてこの共通鍵で暗号化される。
3. クライアントは、共通鍵の元（プリマスターシークレット）を、サーバーの「公開鍵」で暗号化してサーバーに送る。
4. サーバーとクライアントは、お互いに「これまでのハンドシェイクが改ざんされていないか」を確認するメッセージ(Finished)を送り合う。

- [ ] A. 3 -> 2 -> 1 -> 4
- [ ] B. 3 -> 1 -> 2 -> 4
- [ ] C. 1 -> 3 -> 2 -> 4
- [ ] D. 2 -> 3 -> 1 -> 4

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
1. **Key Exchange**: クライアントで作った「秘密の種」を、サーバーの公開鍵を使って安全に送ります。
2. **復号**: サーバーは秘密鍵を使ってその種を取り出します。（これで双方が同じ種を持ちました）
3. **Session Key生成**: その種から、実際に使う「共通鍵」を計算します。
4. **Finished**: 最後にテスト通信をして、鍵が合っているか、ここまでの通信が改ざんされていないかを確認します。
</details>

### Q15. 暗号化のカギとなる「プリマスターシークレット（共通鍵の元）」の生成と配送について、正しい説明はどれですか？ (単数選択)
- [ ] A. サーバーが生成し、そのまま平文でクライアントに送る。
- [ ] B. クライアントが生成し、サーバーの公開鍵で暗号化してサーバーに送る。
- [ ] C. 認証局(CA)が生成し、メールで両者に配送する。
- [ ] D. サーバーとクライアントが同時に別々の値を生成し、それを合体させる。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**ここがハイブリッド暗号の最重要ポイントです。**
- **B**: 正解。共通鍵の元となる大事なデータ（プリマスターシークレット）を作るのは**クライアント**です。そして、それを**サーバーの公開鍵**という「カギのかかる箱」に入れて送ります。この箱を開けられるのは、秘密鍵を持っている本物のサーバーだけです。これにより、盗聴者に中身を見られることなく安全に共通鍵の素材を渡せます。
</details>

### Q16. ハンドシェイクで使われる鍵の役割について、空欄に入る語句の組み合わせとして正しいものはどれですか？

> クライアントは、生成した「プリマスターシークレット」を安全に送るために **( ① )** を使う。
> その後、実際のHTTPリクエスト（HTMLや画像データなど）を暗号化するために **( ② )** を使う。

- [ ] A. ①: 共通鍵 / ②: セッションID
- [ ] B. ①: サーバーの公開鍵 / ②: 生成した共通鍵
- [ ] C. ①: 自分の秘密鍵 / ②: 相手の公開鍵
- [ ] D. ①: サーバーの秘密鍵 / ②: サーバーの公開鍵

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**公開鍵暗号と共通鍵暗号の使い分け** の核心です。
- **① 公開鍵**: 重要な「鍵の元」を送るときだけ使います（遅いが安全）。
- **② 共通鍵**: 大量のデータを送るときに使います（速い）。
</details>

### Q17. ハンドシェイクが完了した後、実際のWebページデータ（HTMLなど）の送受信は何を使って暗号化されますか？ (単数選択)
- [ ] A. サーバーの公開鍵
- [ ] B. クライアントの公開鍵
- [ ] C. CAの秘密鍵
- [ ] D. ハンドシェイクで生成・共有した「共通鍵」

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: D**

**解説:**
ハンドシェイク（公開鍵暗号技術など）はあくまで「共通鍵」を安全に共有するための準備です。実際のデータ通信は、処理速度の速い「共通鍵暗号」で行われます。
</details>

---

## 第5部: 改ざん検知・セキュリティ (概念)

### Q18. TLS通信において「改ざん」を検出するために使われる技術はどれですか？ (単数選択)
- [ ] A. MAC (Message Authentication Code / メッセージ認証コード)
- [ ] B. CRC (Cyclic Redundancy Check / 巡回冗長検査)
- [ ] C. パリティビット
- [ ] D. 共通鍵による暗号化そのもの

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A**

**解説:**
- **A**: 正解。共通鍵とメッセージから生成されるハッシュ値のようなもので、鍵を知っている同士でしか正しい値を計算できないため、意図的な改ざんを検知できます。
- **B, C**: これらは通信エラーなど「偶発的なデータ破損」を検出するための技術であり、攻撃者が意図的に整合性を保ったまま改ざんすることを防ぐ能力（耐タンパー性）はありません。
- **D**: 暗号化は「盗聴」を防ぐもので、暗号化されたデータの一部をデタラメに書き換えることまでは防げません（復号時にゴミデータになるだけか、CBCモードなどではパディングエラーになるが、完全性の保証とは異なります）。
</details>

### Q19. 「ハッシュ関数」の特徴として正しいものをすべて選んでください。 (複数選択)
- [ ] A. 同じデータからは必ず同じハッシュ値が生成される。
- [ ] B. ハッシュ値から元のデータを復元することは（事実上）不可能である。
- [ ] C. データが1ビットでも変わると、ハッシュ値はまったく異なるものになる。
- [ ] D. 任意の長さのデータから、固定長のハッシュ値を生成する。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A, B, C, D すべて**

**解説:**
これらすべての性質がSSL/TLSの署名や改ざん検知の基盤となっています。特に「一方向性（B）」と「衝突耐性（異なるデータから同じハッシュ値ができにくい）」が重要です。
</details>

---

## 第6部: 実践・トラブルシューティング (ケーススタディ)

### Q20. あなたが開発したWebアプリにアクセスしたところ、ブラウザに「この接続ではプライバシーが保護されません (NET::ERR_CERT_DATE_INVALID)」と表示されました。疑うべき原因はどれですか？ (単数選択)
- [ ] A. サーバー側の時刻設定が大幅にずれており、証明書の有効期間外と判定されている。
- [ ] B. サーバー証明書の有効期限が切れている。
- [ ] C. クライアント端末（PCやスマホ）の時刻設定が数年前にずれている。
- [ ] D. 接続先のドメイン名と、証明書のSAN（Subject Alternative Name）に含まれるドメインが一致していない。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
`ERR_CERT_DATE_INVALID` は証明書の日付が無効（期限切れ、あるいは開始前）であることを示します。
- **B**: 最も直接的な原因です。SSL証明書には有効期限があり、更新忘れはよくあるトラブルです。
- **A, C**: これらも実は**正解の可能性があります**。SSL/TLSの有効期限判定は「現在時刻」と比較するため、サーバーかクライアントどちらかの時計が狂っていると、有効な証明書でも「期限外」と判定されてこのエラーが出ます。トラブルシューティングの初手として時刻確認は重要です。
- **D**: これは `ERR_CERT_COMMON_NAME_INVALID` という別のエラーになります。
</details>

### Q21. 開発環境のAPIサーバー（IPアドレス: 192.168.1.10）に対して、自己署名証明書を設定しました。このAPIを叩くスマホアプリ側で通信エラーになります。適切な対処法はどれですか？ (複数選択)
- [ ] A. 本番運用では、信頼できるCAから発行された正規の証明書を使用する。
- [ ] B. 開発中の暫定対応として、アプリ側のＨＴＴＰクライアント設定で「証明書検証を無視する（Insecure）」設定を入れる（ただし本番ビルドには絶対に入れない）。
- [ ] C. 自己署名証明書のルート証明書を、スマホ端末のトラストストア（信頼する証明書一覧）にインストールする。
- [ ] D. 自己署名証明書の暗号強度を、より高い 4096bit RSA に変更して再発行する。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A, B, C**

**解説:**
- **A**: 最終的な正解。本番では必ず公的CAを使います。
- **B**: 開発初期によく行われる回避策。ただしリリース時に消し忘れると重大な脆弱性になるため注意が必要です（アプリ審査でも落とされます）。
- **C**: **最も推奨される開発環境の作り方です。**
    - **トラストストアとは**: PCやスマホの中に最初から入っている「信頼できるルート証明書（CA）のリスト」のことです。
    - **仕組み**: オレオレ証明書は、誰も知らない「オレオレCA」が発行したものです。当然、スマホのトラストストアには入っていないため、「誰だこいつは（信頼できない発行者）」とエラーになります。
    - **解決策**: オレオレCAの「ルート証明書（公開鍵）」を、スマホの設定画面から手動でインストールし、「信頼する」スイッチをオンにします。すると、そのオレオレCAが発行した証明書も（Googleなどの証明書と同様に）正規の証明書としてパスするようになります。
- **D**: **不正解**。暗号強度をどれだけ高くしても「誰が署名したか（信頼の起点）」が不明なままであることには変わりないため、検証エラーは解消しません。
</details>

### Q22. 「中間者攻撃（Man-in-the-middle attack）」について、HTTPSが防げる仕組みとして正しい説明をすべて選んでください。 (複数選択)
- [ ] A. 攻撃者が通信を傍受しても、共通鍵を持っていないため内容を解読できない。
- [ ] B. 攻撃者が通信に割り込み、サーバー証明書を偽造しても、暗号化アルゴリズムが複雑すぎて解読に100年以上かかるため現実的に安全である。
- [ ] C. 攻撃者がDNSを書き換えて偽サイトに誘導しようとしても、ブラウザが「接続先ドメイン」と「証明書のドメイン」の不一致などを検知して警告を出すため、ユーザーが気付ける。
- [ ] D. 通信経路上のルーターやプロキシサーバーは、HTTPS通信であっても全てのパケットの中身を検閲・保存する義務が法律で定められている。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A, C**

**解説:**
HTTPSは、中間者攻撃に対して「盗聴」と「なりすまし」の両面で防御します。
- **A (盗聴防止)**: 攻撃者が途中でパケットを拾っても、暗号化されているため意味のある情報を盗めません。
- **C (なりすまし防止)**: 攻撃者が「私が本物のサーバーです」と嘘をついて割り込もうとしても、正規のCAが署名した「そのドメイン用の証明書」を持っていなければ、ブラウザが警告（ERR_CERT_COMMON_NAME_INVALID 等）を出して接続をブロックしてくれます。
- **B**: 不正解。「解読に時間がかかる」は暗号強度の話で、中間者攻撃（なりすまし）の直接的な解決策ではありません。
</details>

### Q23. 「ドメイン認証(DV)」「企業実在認証(OV)」「EV認証」の違いについて、正しい記述はどれですか？ (単数選択)
- [ ] A. 暗号化の強度は EV > OV > DV の順に強い。
- [ ] B. 暗号化の強度はどれも同じだが、発行時の審査の厳格さと、証明書に含まれる身元情報の信頼性が異なる。
- [ ] C. DV証明書は個人でも取得できるが、スマホでは使えない。
- [ ] D. EV証明書は現在は廃止されており、使われていない。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**暗号化の技術的な強度はどれも同じです**。
違いは「誰にお墨付きを与えるか」の審査レベルです。
- **DV (Domain Validation)**: ドメイン持ってる？（機械審査、安い/無料）
- **OV (Organization Validation)**: 会社実在する？（書類審査あり）
- **EV (Extended Validation)**: 本当にその組織？（厳格な審査、かつてはアドレスバーが緑になった）
</details>

### Q24. 今日のWeb標準において、推奨されるTLSのバージョンと設定について正しいものはどれですか？ (単数選択)
- [ ] A. TLS 1.0 と 1.1 は脆弱性があるため無効化し、TLS 1.2 および 1.3 を有効にする。
- [ ] B. 互換性を最大にするため、SSL 3.0 から TLS 1.3 まで全て有効にする。
- [ ] C. TLS 1.3 はまだ新しいので危険であり、TLS 1.0 だけを使うべきである。
- [ ] D. 暗号化なしのHTTPをメインにし、ログイン画面だけHTTPSにするのが最善である。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A**

**解説:**
SSL 3.0, TLS 1.0, 1.1 はすでに多くの脆弱性（POODLE, BEAST等）が見つかっており、主要ブラウザでも無効化されています。
現在は **TLS 1.2** が最低ライン、**TLS 1.3** が推奨です。
また、Dのような「部分的なHTTPS」はCookieの盗聴などのリスクがあるため、現在はサイト全体の常時SSL化（Always-On SSL）が標準です。
</details>

---

## 第7部: 発展・運用実務 (追加問題)

### Q25. 「証明書チェーン」と「中間証明書」について、正しい運用はどれですか？ (単数選択)
- [ ] A. 中間CA証明書はブラウザに標準で入っているため、サーバーに設定する必要はない。
- [ ] B. サーバー証明書と一緒に、チェーンとなる中間証明書もサーバー設定に含めてクライアントに送る必要がある。
- [ ] C. ルート証明書だけをサーバーに設定すればよい。
- [ ] D. サーバー証明書のファイルサイズを小さくするために、中間証明書は削除するべきだ。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
**実務で最も多いトラブルの一つです**。
PCブラウザは中間証明書を補完する機能を持っていたり、キャッシュしていたりして表示できることがありますが、スマホやAPIクライアントはシビアで、サーバーから中間証明書が送られてこないと「証明書エラー（信頼できない発行者）」として接続を拒否します。必ずサーバーには「サーバー証明書＋中間証明書」を設定する必要があります。
</details>

### Q26. 1つのIPアドレスで複数の異なるドメイン（例: a.com, b.com）のHTTPSサイトをホストすることを可能にする技術はどれですか？ (単数選択)
- [ ] A. DNSラウンドロビン
- [ ] B. SNI (Server Name Indication)
- [ ] C. VPN
- [ ] D. NAT

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
従来のSSL/TLSハンドシェイクでは、どのドメイン宛の通信か（Hostヘッダ）は暗号化されたHTTPの中にあるため、サーバーはハンドシェイクの段階で「どの証明書を使えばいいか」わかりませんでした。
**SNI** は、ハンドシェイクの最初の段階（Client Hello）で「アクセスしたいホスト名」を平文で通知する拡張仕様です。これにより、バーチャルホスト環境でも適切な証明書を提示できるようになりました。
</details>

### Q27. Let's Encryptなどの一部のモダンなCAが発行する証明書の有効期限が「90日」と短い理由として、正しい説明をすべて選んでください。 (複数選択)
- [ ] A. 秘密鍵が漏洩した場合のリスク期間を短くするため。
- [ ] B. 証明書の更新（再発行）プロセスを自動化することを前提としているため。
- [ ] C. サイト所有者がドメインを管理し続けているかを確認する頻度を高めるため。
- [ ] D. 短期間でサーバーを再起動させることで、メモリリークなどの不具合を解消させるため。

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A, B, C**

**解説:**
- **A, B, C**: これらすべてもっともな理由です。
    - **A**: 有効期限が長いと、鍵が漏れても長期間悪用されるリスクがありますが、短期更新ならそのリスクを減らせます。
    - **B**: 90日ごとに手動更新するのは大変なので、`certbot` などのツールで自動更新することが半ば強制されます。これにより「更新忘れ」による事故を防ぐ文化を作っています。
    - **C**: ドメインの持ち主が変わったのに古い証明書が有効なままだと危険です。頻繁な更新で所有権を再確認します。
- **D**: 間違いです。運用の副作用としてはあるかもしれませんが、証明書の有効期限を短くする本来の目的ではありません。
</details>

### Q28. HTTPSサイトの中に、一部の画像やスクリプトが `http://` で埋め込まれている状態を何と呼びますか？ (単数選択)
- [ ] A. クロスサイトスクリプティング (XSS)
- [ ] B. 混在コンテンツ (Mixed Content)
- [ ] C. ダブルサブミッション
- [ ] D. オープンリダイレクト

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: B**

**解説:**
HTTPSページ内に安全でないHTTPリソースが含まれると、鍵マークが消えたり警告が出たり、場合によってはブラウザによって読み込みがブロックされます。完全にHTTPS化するには、読み込むリソースもすべて `https://` にする必要があります。
</details>

### Q29. ウェブサイトがブラウザに対して「次回からは必ずHTTPSで接続してほしい」と指示するレスポンスヘッダーはどれですか？ (単数選択)
- [ ] A. Strict-Transport-Security (HSTS)
- [ ] B. Content-Security-Policy (CSP)
- [ ] C. Access-Control-Allow-Origin
- [ ] D. X-Frame-Options

<details>
<summary><strong>正解と解説を確認する</strong></summary>

**正解: A**

**解説:**
**HSTS (HTTP Strict Transport Security)** ヘッダーを受け取ったブラウザは、指定期間内であれば、ユーザーが `http://` と入力しても内部的に自動で `https://` に変換してアクセスします。これにより、中間者攻撃によるダウングレード攻撃やCookieの盗聴リスクを減らすことができます。
</details>
